\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}

\begin{document}

\title{System-level Programming}
\author{Avery Karlin}
\date{Fall 2015}

\maketitle
\newpage
\tableofcontents
\vspace{11pt}
\noindent
\underline{Teacher}: Dyrland-Weaver
\newpage

\section{Learning C}
\subsection{C Primitive Variable Types}
\begin{enumerate}
\item All C primitives are numeric, divided purely based on variable size, and integer or floating point
\begin{enumerate}
\item C variables have sizes based on the platform they were compiled by and for, such that sizeof(\textit{type}) can be used to determine the size in bytes
\item On a standard computer, int = 4 $(-2^31, 2^31 - 1)$, short = 2, long = 8, float = 4, double = 8, and char = 1 bytes (8 bits to a byte)
\item Types can also be specified as unsigned, such that it is not able to be given a negative value
\item Types can be placed within types of larger size and the same format without any form of conversion, but not of a different format
\item sizeof(\textit{type}) returns the size in bytes of the type
\end{enumerate}
\item Boolean values are numbers, such that 0 is false, and all nonzero numbers are considered true
\item Character literals can be represented inside single quotes rather than use a number, and Strings, though not an object, can use a double quotes literal
\begin{enumerate}
\item Strings are created by character arrays, using a null character (value 0), to show the end of the array, allowing it to be modified easier
\end{enumerate}
\item Variables are able to be initialized within a for loop, but are not able to be declared, such that it must be before the loop
\item ``typedef \textit{var-type} \textit{new-name}'' allows you to call an existing variable by a different name
\begin{enumerate}
\item Typedef is typically used within the header to allow the term to be used throughout the program
\end{enumerate}
\end{enumerate}

\subsection{C Compilation}
\begin{enumerate}
\item They are compiled through ``gcc \textit{file.c} -o \textit{program\_name}'', then run through ``./\textit{program\_name}''
\item C programs can be compiled into one executable, such that there is just one file after another in command line, though since they are compiled in the same namespace, they cannot have the same global variables or function names
\item The same is true for files called within other files, though those are compiled automatically
\item C programs must have exactly 1 main() function to compile, creating issues when multiple files have a main()
\item ``gcc -c \textit{file.c}'' creates a binary object .o file, which can be run through other exectuable files, and can be compounded similarly during compiling
\begin{enumerate}
\item Binary object files are used for files without a main method, and are non-executable
\item Binary object files can be linked to a .c file through compound compiling with the first file as the .c file
\item Thus, the .o file is dependant on all .h files and the .c file, while the executable is dependent on the .o files, .h files, and the main .c file
\item The .o file can then be compiled identically to .c files
\end{enumerate}
\item If ``-o \textit{program\_name}'' is not put in, the default executable name is ``a.out''
\item Projects with large numbers of dependencies can have a file called ``makefile'' to organize creation of the executable with dependencies
\begin{enumerate}
\item The makefile is ordered from the most dependent level to least dependent (ignoring non-dependent files and standard libraries)
\item Format is: \\ \textit{Target-Filename: dependency1 dependency2}\\ $<$tab$>$ \textit{Terminal compilation code for file}
\item ``make \textit{target-filename}'' command is used when in the directory to compule the project using the make file
\item The clean targets can be used to remove files from the directory after compilation
\item The all target can be used to compile the entire program
\item Any bash commands can have a makefile target made, such that it can be used with a ``run'' target to run commands faster (though any target can be used)
\item The first target in a makefile is the default if just ``make'' is written in terminal
\end{enumerate}
\end{enumerate}

\subsection{C Programming}
\begin{enumerate}
\item All C programs are made up of a series of functions, run within the main function, which returns an integer (typically 0, or other values for errors)
item Libraries are added, either .h files from the current directory through \#include ``\textit{file}.h'' or through premade libraries by \#include $<$file.h$>$
\begin{enumerate}
\item All files typically start with calling the C library with \#include$<$stdio.c$>$ (standard io) and $<$stdlib.h$>$ (standard library)
\end{enumerate}
\item The man pages, called by ``man \textit{command}'' or ``man \textit{section command}'', give information on both bash and C commands
\begin{enumerate}
\item (1) is user commands, (2) is system calls, (3) is library functions, such as the C libraries, (4) is devices, (5) is file formats, (6) is games and amusements, (7) is conventions and miscellany, and (8) is system admin and priveledged commands
\item (L) is used for local commands, installed by certain programs
\end{enumerate}
\item C functions are pass by value, such that they put the value into a new variable created by the function, though if pointers are passed, it is equivelent to pass by reference, due to being a ppointer to the same location
\begin{enumerate}
\item C functions are written similar to java, with the exception of the lack of the protection
\item Due to C being functional, the functions are created in the order written, such that it should already have created all functions and commands used within the function being compiled
\item Failure to declare first leads to an implicit declaration warning that it has not been formally declared yet, though it will still work if it is declared later
\item Headers can also be placed at the top of the function in addition to where they are defined, to avoid implicit declaration, or in a seperate header file
\end{enumerate}
\end{enumerate}

\subsection{C Structures}
\begin{enumerate}
\item ``printf(\textit{text, var1, var2})'' is used to print a String in terminal, where the text is a formatted string, with placeholders for variables following
\begin{enumerate}
\item \%f is a placeholder for a float, \%d for double, \%c for char, \%s for string, \%f for pointer, \%lf for double, \%ld for long, and \%d for int
\item println can be used instead of printf for non-formatted strings (without variables)
\item Print functions do not automatically add ``\\n'' at the end of a line, and must be written in the string
\end{enumerate}
\item Arrays in C are non-dynamic, such that they must have a fixed size, with no length function, and there are no errors for going outside boundries, rather going to a different point in memory
\begin{enumerate}
\item Arrays are declared by ``\textit{type}[\textit{size}];'' and must be initialized each part at a time
\end{enumerate}
\item String functions are held within the string.h library, always assuming the strings are null-terminated
\end{enumerate}

\section{Memory Management}
\subsection{Memory Allocation}
\begin{enumerate}
\item Memory allocation is either during compile time (static stack memory), or during runtime (dynamic heap memory)
\item Compiler allocated memory is packaged within the binary, unable to be overwritten by other programs due to protected memory, without a default value, where variables and arrays are allocated
\begin{enumerate}
\item Memory addresses of variables are fixed once they are placed, such that the data can be changed, but the location cannot be
\item Variable names are not stored, but rather substituted for memory locations during compilation
\item Once the function/scope under which the stack memory created is finished, the memory is automatically released
\end{enumerate}
\item Systems have a bit limit which they can read at once, such that 32 bit systems are limited to 32 bit unsigned values, such that $[0, 2^32-1]$ is possible, or ~4 GB 
\item Pointers are variables designed to store memory addresses, stored within the stack
\begin{enumerate}
\item \%\textit{variable} is used to get the address of a variable, such that the number returned can be the value of a pointer 
\item When a pointer is incremented, the location moves the number of bytes of the variable type which the pointer applies to
\item * is used before a variable name to declare a pointer, and is also used when calling a variable to get the value of the item at that location, preceeding before numeric operators except ++ and --
\item Thus, for some array a, with *a as the pointer, a[i] = *(a + i)
\item Null pointers (set equal to the location 0) are often used to signify the end of a list
\end{enumerate}
\item Other sections in memory are code (the executable section of an object file, often stored in ROM until run), bss (global or static uninitialized variables), and data (global or static initialized variables)
\item Variables marked by the ``const'' keyword have the value stored in the read-only portion of the same memory space they would normally exist in
\item String literals are generally stored within the code section, though it can occasionally be stored in the data section as a static variable
\end{enumerate}

\subsection{Strings and Arrays}
\begin{enumerate}
\item Strings can be declared by several methods, "char \textit{str[byte\_num]}" to do basic allocation, or it can be set on the same line, with a null put in the byte after the last letter
\begin{enumerate}
\item It can also be declared with an empty byte number, but set such that it will be given the exact amount of space needed
\item It can also be declared as a pointer to the array by "char *\textit{str = data}", created the array the exact correct size, and a pointer to the array under that variable name
\item After declaration, each character must be set individually, instead of using the equal sign
\item On the other hand, if a pointer is used, the pointer can be changed to apply to a seperate array, using an equal sign, even after declaration
\end{enumerate}
\item The null character at the end is needed for string functions in string.h to work correctly, but is not a requirement
\item String/array variables are functionally immutable pointers to the first item in an array (such that the location cannot be changed)
\item Pointer-defined strings are literals, such that they are made in protected memory, where the pointer location can be redefined, but the string cannot be
\begin{enumerate}
\item Literals of the same string will point at the same location as previously made literals, stored fully in static stack memory
\end{enumerate}
\end{enumerate}

\subsection{Dynamic Memory Allocation}
\begin{enumerate}
\item (\textit{type} *)malloc(int \textit{byte-num}) allocates that number of bytes from the head, returning the location of the first byte, typecasting the pointer to the type specified
\begin{enumerate}
\item sizeof(\textit{type}) is often used to allocate the correct amount of memory
\item calloc is a similar function that sets each bit to 0, otherwise acting like malloc, though with a first parameter to determine the number of data pieces created
\item malloc returns a void pointer, such that it can be typecast to any type of pointer
\end{enumerate}
\item realloc(void *p, int \textit{new-byte-num}) will return any extra bytes, or add additional bytes to the allocation
\item Normal memory allocation happens on the stack, automatically released after the function which created it ends
\item Dynamic memory allocation happens on the heap, kept even after the function that created it is removed from the stack, such that it must be released
\begin{enumerate}
\item free(\textit{pointer}) releases the dynamically allocated memory which the pointer goes to
\item Dynamic memory should always be released in the program when created, and can prevent filling the memory
\item After the program is ended, the memory is freed automatically, but it can freeze the computer if filled before then, such as in an infinite recursion
\end{enumerate}
\end{enumerate}

\subsection{Shared Memory}
\begin{enumerate}
\item Shared memory is a segment of heap memory able to be accessed by multiple processes, not released when a program exits, accessed by a specific key
\item Shared memory functions are within ``sys/shm.h'', ``sys/ipc.h'', and ``sys/types.h''
\item Shared memory can be created or removed, as well as accessed or attached/deattached from a variable once per process
\item shmget(\textit{key, size, flags}) - Creates or accesses a shared memory segment, where key is a unique identifier
\begin{enumerate}
\item Size is the number of bytes requested
\item Flags are the permissions, able to be combined by bitwise OR with IPC_CREAT (creates the segment if it doesn't exist, setting all values to 0) 
\item Returns the descriptor of the memory (or -1/errno if it fails)
\end{enumerate}
\item ftok(\textit{path, x}) - Generates a unique key, based on the path to some accessible file, and an integer
\begin{enumerate}
\item The generated key will be the same for the same path and integer, each time run
\end{enumerate}
\item shmat(\textit{descriptor, pointer, flags}) - Attaches the shared memory to the pointer, or to available memory space if null pointer is given
\begin{enumerate}
\item Returns the pointer or -1/errno if it fails
\item SHM\_RDONLY attaches the shared memory as read-only, such that the pointer value cannot be modified
\end{enumerate}
\item shmdt(\textit{pointer}) - Deattaches pointer variable from shared memory, such that while the data is still in shared memory, it can no longer be accessed in the program
\item shmctl(\textit{descriptor, command, buffer}) - Controls shared memory by the command (IPC\_STAT for populating buffer struct with metadata information, IPC\_SET for setting segment info to buffer, or IPC\_RMID for removing segment)
\begin{enumerate}
\item Meta-data is stored within a ``struct shmid\_ds'' containing last access, size, PID of creator, PID of last modification, etc
\end{enumerate}
\end{enumerate}

\section{Structural Functions}
\subsection{String Functions}
\begin{enumerate}
\item String functions are found within <string.h>, assuming a null character at the end
\item int strlen(char *s) returns the length of s, ignoring the null character
\item int strcmp(char *s1, char *s2) returns 0 if equal, >0 if s1 > s2, and <0 otherwise
\item char* strcpy (char *destination, char *source) copies the string to destination, assuming the allocated destination space is the same size or larger
\item char* strcat (char *destination, char *source) adds source to the end of destination
\item strncat and strncpy has an integer as a final parameter, using only the first n characters of the source string, such that if it is longer than the string, it uses up to the null character 
\item char* strsep(char* source, char* delimeter) - Replaces each occurance of the delimeter, replacing the first character of the first occurance of the delimeter with NULL
\begin{enumerate}
\item The source must be a pointer to the string pointer (not array, due to needing to be mutable) variable, and is modified such that it points to the character after the delimeter, or null if there is no instance
\item Returns the original source, before changed
\end{enumerate}
\item sprintf(\textit{char* str, char* format, var1, var2,...}) - Converts the variables into a string of the format specified by the format string, made up of placeholders, stored within str, returning the number of characters in the string 
\end{enumerate}

\subsection{Struct}
\begin{enumerate}
\item Structs are a collection of values within a single data type, declared by struct\{\textit{type1 var1; type2 var2}\} as the type name
\begin{enumerate}
\item Typedef is used to create a simple type name for it
\item If the struct type itself is needed within the struct, it can be declared implicitly within the typedef, by putting ``struct type-name var'' instead of just the type
\end{enumerate}
\item \textit{struct-name.subvar} is used to call a specific item within the struct
\item Since . operator has precedence over *, pointers to structs either must get the struct data before getting a specific piece of data, or use ``\textit{pointer-to-struct} -> \textit{struct-var} to do 
\end{enumerate}

\subsection{Union}
\begin{enumerate}
\item Union data types are defined similarly to structs, using the keyword ``union'' instead, used to store multiple types of data within the same memory
\item Unions only set the maximum size to the largest of the possible types, such that the data is used similarly to a struct item
\item Unions are only able to store a single type of data at a time
\end{enumerate}

\section{File Programming}
\subsection{Permissions}
\begin{enumerate}
\item There are 3 permission areas, each with their own permission value, first the creator (user), then a specific group of users (group), then everyone else (others), each mutually exclusive
\begin{enumerate}
\item The owner always has the ability to delete and change the permissions of a file, even if the permission value is 0
\end{enumerate}
\item ABC is the permissions of an area in binary, where A = read, B = write, C = execute, such that it can be converted into a number 0-7 in octal (which must be written in code with a 0 first, to tell the compiler it is octal)
\end{enumerate}

\subsection{Bitwise Operators}
\begin{enumerate}
\item \& is the bitwise AND operator, | is OR, ~ is NOT, and \^ is XOR
\item Bitwise operators are used to modify the actual binary of equal lengths, going bit by bit
\end{enumerate}

\subsection{File Usage}
\begin{enumerate}
\item The file table is a list of all files used by a program while it it running, containing basic information such as location and size
\begin{enumerate}
\item The file table has a limited size of $2^n$, typically 256, where getdtablesize() in ``unistd.h'' returns the size value;
\item Each file is given a descriptor, or an integer index from 0, and the table records the path, location, and other data 
\item File descriptor 0 (or STDIN\_FILENO) always refers to stdin (standard command line input), and 1 (or STDOUT\_FILENO) refers to stdout
\item File descriptor 2 (or STDERR\_FILENO) refers to stderr (standard error), which contains all error messages produced by the compiler, similar to stdout
\item These are automatically opened on the opening of a C program
\end{enumerate}
\item open(\textit{file\_path, flags, mode}) - Opens/adds the file to the first open file table space, returning the file descriptor
\begin{enumerate}
\item File descriptor -1 is returned when the file opened does not exist, or there is not permission to access the file
\item When open() fails, the variable ``errno'' in ``errno.h'' is automatically set for the specific type of error
\item strerror(\textit{int}) in ``string.h'' returns a string describing the integer stored in errno
\item Found within ``fcntl.h''
\item Flags are used to declare what the file is being used for, while mode is only used if creating the file, setting the permissions as an octal number
\item Flags can be:
\begin{itemize}
\item O\_RDONLY - Read only
\item O\_WRONLY - Write only
\item O\_RDWR - Read and Write
\item O\_APPEND - Write to end of file only
\item O\_TRUNC - Erase file and write over
\item O\_CREAT - Create file and open it if it exists
\item O\_EXCL - Can be combined with O\_CREAT to return an error if it exists
\end{itemize}
\end{enumerate}
\item close(\textit{file\_descriptor}) removes the file from the file table, found within ``unistd.h''
\item read(\textit{file\_descriptor, buffer, amount}) reads text from a file, where buffer is a pointer to where the text is placed, and amount is the bytes read
\begin{enumerate}
\item Returns the number of bytes read, or -1 if it fails (setting the errno value)
\end{enumerate}
\item unmask(\textit{mask}) sets the file creation permission mask, found within ``sys/stat.h''
\begin{enumerate}
\item Files are not initially given the permissions in the mode argument when opened, when they are created, such that a mask must be applied to modify
\item The new permissions when opened are thus ~mask \& mode, shutting off all permission from the mask
\item The mask should be in octal form, adding a new mask to the permissions
\end{enumerate}
\item lseek(\textit{file\_descriptor, offset, whence}) sets the current position in an open file, where offset is the number of bytes to move by
\begin{enumerate}
\item Whence can either be SEEK\_SET (beginning of the file), SEEK\_CUR (current position in the file), or SEEK\_END (end of the file)
\item Returns the number of bytes from the current position to the start of the file, or -1 in case of error, setting errno
\item Found within ``unistd.h''
\end{enumerate}
\item write(\textit{file\_descriptor, buffer, amount}) writes to the file the data from the buffer (which must be a pointer), where amount is the number of bytes written
\begin{enumerate}
\item Returns the int number of bytes written
\item Found within ``unistd.h''
\end{enumerate}
\end{enumerate}

\subsection{Metadata}
\begin{enumerate}
\item Metadata is information stored in the filesystem outside of files
\item ``struct stat'' is a built-in struct for metadata, where the stat(\textit{path, stat\_buffer}), where the stat buffer is the pointer to the stat struct, setting the struct to refer to the file
\item Stat struct fields include:
\begin{itemize}
\item st\_size - int, file size in bytes
\item st\_uid - int, user id
\item st\_gid - int, group id
\item st\_mode - int, file permissions
\item st\_atime - time\_t, last access time
\item st\_mtime - time\_t, last modification time
\end{itemize}
\end{enumerate}

\subsection{Directories}
\begin{enumerate}
\item Directory streams are stored within the DIR variable, and its pointer, stored along with their functions in ``dirent.h''
\item opendir(\textit{path}) - Returns a pointer to the directory stream, but does not change the current working directory (cwd)
\item closedir(\textit{directory\_stream}) - Closes the directory, and frees the stream variable automatically
\item readdir(\textit{directory\_stream}) - Returns a pointer to the next entry within the directory stream, or null if the stream is at the end
\item rewinddir(\textit{directory\_stream}) - Moves the directory stream to the start
\item ``struct dirent'' is a built-in struct for entries within a directory streams, stored within ``sys/types.h''
\begin{itemize}
\item d\_name - char[], name of files within the directory
\item d\_type - int, file type
\end{itemize}
\end{enumerate}

\subsection{Inputs}
\begin{enumerate}
\item scanf(\textit{format\_string, var1, var2, ...}) - Takes a string from stdin, matching the items from the string to variables within the format string (made up of placeholders), stored within the pointers, var1, var2, ...
\begin{enumerate}
\item sscanf(\textit{string, format\_string, var1, var2, ...}) - Takes the string, scanning data from it similarly to scanf
\end{enumerate}
\item fgets(\textit{string\_pointer, bytes, file\_pointer}) - Reads data from the file pointer to the string pointer
\begin{enumerate}
\item It stops after writing the byte number - 1 (giving space for \\0), first newline, or the end of file character, placing \\0 (null at the end)
\end{enumerate}
\item ``int argc, char *argv[]'' can also be put as the parameters of the main() function, to allow command line arguments, starting from the bash commands themselves
\end{enumerate}

\section{Processing}
\subsection{Processes}
\begin{enumerate}
\item Each running program is a process, such that each core in a processor can handle one process per cycle, only appearing to multitask due to the high speed
\item Each process has a unique PID, recycled when the machine is restarted
\item PIDs can be stored in pid\_t type variables, found in ``sys/types.h'', displayed as an integer number
\end{enumerate}

\subsection{Process Functions}
\begin{enumerate}
\item getpid() - Returns the current PID, stored within ``unistd.h''
\item getppid() - Returns the current process's parent PID, stored within ``unistd.h''
\item sleep(\textit{int seconds}) - Makes the processor rest for that many seconds, stored within ``stdlib.h''
\item fork() - Stored within ``unistd.h'', creating a child subprocess from the parent
\begin{enumerate}
\item All aspects of the parent, including memory and file table are copied to the child process when it is forked, continuing from the same line in the child
\item Threads are different from child processes, such that they do not have their own copied memory, rather sharing the same memory
\item 0 is returned to the child, while the child PID is returned to the parent
\item If it fails, -1 is returned and errno is set
\end{enumerate}
\item wait(\&\textit{int status}) - Waits in the parent process until at least one child process has returned information
\begin{enumerate}
\item status stores a return value as the first byte from the process (not the C return, but the process return), followed by other info, such that WEXITSTATUS(status) gives only the return value
\item Returns the PID of the child exited, or -1 (setting errno) if it fails
\end{enumerate}
\item waitpid(\textit{pid, \&status, options}) - Waits for a specific chid to complete, where options defaults to 0 for normal behavior, and where -1 as the pid waits for any child
\item exit(\textit{int return}) - Ends the process and returns the process return value, found in ``unistd.h''
\end{enumerate}

\subsection{Exec Function Family}
\begin{enumerate}
\item Exec functions can be used to run other programs within programs, such that the other program replaces the program within the process, such that code after is ignored
\item Exec functions are found within ``unistd.h''
\item execl(\textit{path-to-including-command, command, arg1, arg2, ...,}, NULL) - Runs the command program, found at the path,  where all non-NULL variables are strings, args are command line arguments, and NULL shows the end of the arguments
\item execlp(\textit{path, command, arg1, arg2, ...,}, NULL) - Runs similar to execl, except using the PATH variable for the start of the path
\item execvp(\textit{path, argument-array}) - Runs similar to execlp, except with an array of the command and command line argument strings
\end{enumerate}

\section{File Redirection}

\subsection{Command-Line Redirection}
\begin{enumerate}
\item \textit{command} $>$ \textit{new\_output} - Redirects stdout from the command into the new\_output file, overwriting the file
\item $>>$ - Redirects, but appends instead of overwrites
\item $2>$ and $2>>$ - Redirects stderr instead of stdout
\item $\&>$ and $\&>>$ - Redirects both stdout and stderr 
\item \textit{command} $<$ \textit{new\_input} - Redirects stdin from the file into the command
\item \textit{command1} | \textit{command2} - Pipes from command1 to command2, or puts the stdout of command1 as the stdin of command2
\end{enumerate}

\subsection{C Redirection}
\begin{enumerate}
\item dup2(\textit{fd1, fd2}) - Redirects the fd2 file descriptor value to refer to fd1, found in ``unistd.h''
\item int dup(\textit{fd1}) - Creates a new entry in the file table, the decriptor of which is returned, which refers to the same file as fd1, found in ``unistd.h''
\end{enumerate}

\section{Signaling}

\subsection{Command-Line Signals}
\begin{enumerate}
\item Signals are a limited way of sending information to a process
\item kill <PID> - Command line utility to send signal 15 (SIGTERM) to terminate the PID
\begin{enumerate}
\item kill <SIGNAL> <PID> - Sends the specified signal instead, such that the process may not be terminated
\item killall <PROCESS\_NAME> - Sends the terminate signal to all processes with PROCESS\_NAME in the name
\item killall <SIGNAL> <PROCESS\_NAME> - Sends the specified signal to those processes
\end{enumerate}
\end{enumerate}

\subsection{Signals in C}
\begin{enumerate}
\item All signal functions are found within ``signal.h''
\item kill(\textit{PID, SIGNAL}) - Sends the signal to the process, returning 0 if succeeding, -1 (with errno) otherwise
\item signal(\textit{SIGNUMBER}, sighandler) - Attaches the signal to the signal handling function, such that it is redirected to the function
\begin{enumerate}
\item Signal handling function must have the header ``static void sighandler(int signo)''
\item Sighandler is static, such that it can only be called from the function it is defined in
\item Some signals, such as SIGKILL, cannot be attached to the sighandler function
\end{enumerate}
\end{enumerate}

\subsection{Semaphores}
\begin{enumerate}
\item Semophores are IPC (interprocess communication) used to control access to shared resources, to prevent editing errors
\begin{enumerate}
\item These act as a counter to determine the number of slots for accessing a process, often used in pairs (one for read, one for write)
\item Semaphores can be set, created, removed, incremented (either signal(), P(), S++, or Up(S) as non-code notation), decremented (wait(), V(), S--, or Down(S))
\item Semaphores are not connected to any particular memory, but rather cause the program to wait until the change in the value is possible (without ending less than 0)
\end{enumerate}
\item Semaphore functions require ``sys/types.h'', ``sys/ipc.h'', and ``sys/sem.h'' to function
\item semget(key\_t key, int amount, int flags) - Creates/accesses a semaphore, returning the descriptor or -1/errno if it fails
\begin{enumerate}
\item The key is the unique semaphore indentifier, determined by ftok()
\item Amount is the number of semaphores within the set, while flags are the permissions for the semaphore
\item Using the bitwise OR, IPC\_CREAT (creates semaphore, setting to 0), and IPC\_EXCL (fails if IPC\_CREAT is used and semaphore exists) can be added to the flags for if being created
\end{enumerate}
\item semctl(\textit{semaphore-descriptor, index, operation, data}) - Controls the semaphore
\begin{enumerate}
\item Index is the index of the semaphore within the set/array identified by the descriptor, while data is only if a specific value is inputted to the semaphore operation
\item This can be used to set, remove, get the value, and get information about the semaphore
\item Operations include IMP\_RMID (remove), SETVAL (set), SETALL (sets all semaphores within the set), GETVAL (returns value), IPC\_STAT (populates buffer with information about the semophore from \textit{data})
\item Data is a union semun data type, able to store the data for any of the possible uses
\begin{enumerate}
\item The union is not included in the header, such that it must be written as: ``union semun {int val; struct semid\_ds *buf; unsigned short *array; struct seminfo *\_\_buff;};
\end{enumerate}
\end{enumerate}
\item semop(\textit{descriptor, operation, amount}) - Modifies the value of the semaphore, as an atomic operation that the memory can not be seen changed until completion 
\begin{enumerate}
\item The amount is the number of semaphores in the set which are being operated on
\item Operation is a pointer to a ``struct sembuf'', precreated, containing short sem\_flg, short sem\_num (index of semaphore), and short sem\_op (-n for down by n, n for up, 0 to have the process sleep until the semaphore is 0)
\item Possible values for sem\_flg are SEM\_UNDO (allows the OS to release the semaphore automatically in case the program crashes, and was unable to release it), IPC\_NOWAIT (if the semaphore is unavailable, it returns an error instead of waiting)
\end{enumerate}
\end{enumerate}

\section{Connections}

\subsection{Pipes}
\begin{enumerate}
\item Pipes are a conduit between two processes, with each pipe containing a read and write end, unidirectional (constant direction), acting like files to transfer data
\item Unnamed pipes have no external identification, such as a name or descriptor
\begin{enumerate}
\item pipe(\textit{int descriptors[2]}) - Creates an unnamed pipe, found within ``unistd.h'', returning 0 if created, -1/errno if it fails
\item The function stores in the descriptors array, the descriptors of the read end and the write end (in that order) of the pipe, such that the data written is stored in the pipe until read
\end{enuemrate}
\item Named pipes, also called FIFO (first in, first out), have a name that can be used to identify them from another program, unidirectional as well
\begin{enumerate}
\item mkfifo(\textit{char* name, int permission}) - Creates a named pipe, requiring ``sys/types.h'' and ``sys/stat.h'', returning 0 if success, -1/errno if it fails
\item The FIFO acts as a file, with permissions inputted, blocking on open (stopping the process from writing or reading) until a connection is established on both ends
\item The FIFO is not opened immediately after created, and is used otherwise the same as any other file, though will block extra processes from allowing reading or writing
\item remove(\textit{char* path}) - Deletes the given file, used to remove the named pipe conduit after connection is established, returning 0 if success, -1/errno otherwise
\item The pipe file descriptor is still valid for use after the conduit is removed, such that communication is still possible, but no new connections can be created
\end{enumerate}
\end{enumerate}

\subsection{Server-Client Protocol}
\begin{enumerate}
\item The handshake procedure is used to ensure a connection is established, first created a named pipe, called a well-known pipe, by the server, which then waits for a connection
\begin{enumerate}
\item The client then creates a named pipe, called a private pipe, which connects to the well-known pipe, and sends the name of the private pipe, after which it waits for the connection
\item The server then recieves the name of the private pipe, removes the well-known pipe, which then connects to the private pipe
\end{enumerate}
\item The basic server uses the handshake, followed by the connection, then after the client exits, the private pipe is removed and a new well-known pipe is created
\item The forking server allows a subserver for each client, allowing for multiple client connections simultaneously
\begin{enumerate}
\item The handshake is done similarly until the point of connecting to the private pipe by the server, at which point it forks a subprocess, and has that connect, finishing the handshake process
\item The variable to the location of the original well-known pipe is then kept by the subserver, but closed in the main server, to allow the new well-known pipe to be created
\item After the connection, the private pipe is removed in the subserver, and the subprocess ends
\end{enumerate}
\item Central dispatch server/Distributed server maintains communication with each of the clients simultaneously through maintaining pipes to each of the subservers, allowing inter-client communication as well
\end{enumerate}

\subsection{Networking}
\begin{enumerate}
\item The OSI 7-layer model is used to conceptualize the different parts of network connections, becoming more abstract (relient on code as the layers get lower), to allow the assumption that all other layers are in place properly, for simplification
\begin{enumerate}
\item The physical layer is the top layer, for the physical connection between computers, generally electrons through copper wires, though it can also be done through radio waves (wi-fi, bluetooth) or light pulses
\begin{enumerate}
\item Thicknet was originally used, consisting of a thick coaxial copper wire with heavy insulation, with a vampire tap to cut into and connect to the cable, to join computers, but as more devices are added, the connection degrades, and it is difficult to modify the setup
\item Thinnet was later used, replacing the vampire taps with a cable T-splitter rather than a vampire tap, to avoid damaging the cable, allowing easily reshaping the networking, and allows repeaters to capture the signal and add electricity to prevent signal degredation
\item The token ring was later invented, connecting every computer to the next and eventually to the first computer in a ring, to prevent signal degredation, preventing data collisions by only one computer having the token, or controlling the network, at one time, with others pausing until they are given the token
\item The network equipment can easily transfer it, in between data usage, gaining full access for a short time, but it gets slower as more computers are added
\item Thicknet, thinnet, and token rings sent all data to all computers automatically
\item In modern day, the ethernet is used as an common alternative to token rings, with multiple computers connecting to a single hub/switch, but there is a possibility of collision and can slow, especially as it gets larger
\item Hubs broadcast the data revieved from a computer to all other computers on the network, while a switch sends the data to a specific computer through the data link layer (routers often also act as switches)
\item Ethernet eliminates the risk of a computer breaking down, causing the entire system to break down
\end{enumerate}
\item The second layer is the data link layer handles point-to-point transmission between devices on the same local network
\begin{enumerate}
\item Each device is given a unique 6-byte MAC (Media Access Control) address, set on the network card when they are made
\item Data is packaged into frames based on the physical protocol, such that the ethernet frame has an 8 byte prefix, 6 byte destination MAC address, 6 byte source MAC address, 6 byte additional information based on ethernet version (...), 46-1500 bytes of data, and the 4 byte checksum 
\item The prefix designates it as an ethernet frame, written by 10101010 seven times, then 10101011
\item If the data is less than 46, it is padded with 0s at the end, while if it is more than 1500, it will be put in multiple frames
\item 1500 bytes is called the maximum transmission unit (MTU)
\item The checksum ensures data integrity by creating a hash of the data to ensure the data recieved and sent are the same
\end{enumerate}
\item The third layer is the network layer, used to transmit data between two different local networks, the main needs of which are to determine where to send data, without requiring broadcasting the MAC address of every computer to every other switch
\begin{enumerate}
\item The network layer ignores the issue of data being sent successfully
\item Internet protocol (IP) addresses are unique addresses, given whenever a computer connects to the internet, generally IPv4 (4 bytes, written as seperate integers with numbers between)
\item IP addresses are given out in large groups, to allow computers to determine which router to send them to, simply based on a single part
\end{enumerate}
\end{enumerate}
\end{enumerate}

\end{document}
