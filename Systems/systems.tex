\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{setspace}
\usepackage{tikz}

\begin{document}

\title{System-level Programming}
\author{Avery Karlin}
\date{Fall 2015}

\maketitle
\newpage
\tableofcontents
\vspace{11pt}
\noindent
\underline{Teacher}: Dyrland-Weaver
\newpage

\section{Learning C}
\subsection{C Primitive Variable Types}
\begin{enumerate}
\item All C primitives are numeric, divided purely based on variable size, and integer or floating point
\begin{enumerate}
\item C variables have sizes based on the platform they were compiled by and for, such that sizeof(\textit{type}) can be used to determine the size in bytes
\item On a standard computer, int = 4 $(-2^31, 2^31 - 1)$, short = 2, long = 8, float = 4, double = 8, and char = 1 bytes (8 bits to a byte)
\item Types can also be specified as unsigned, such that it is not able to be given a negative value
\item Types can be placed within types of larger size and the same format without any form of conversion, but not of a different format
\item sizeof(\textit{type}) returns the size in bytes of the type
\end{enumerate}
\item Boolean values are numbers, such that 0 is false, and all nonzero numbers are considered true
\item Character literals can be represented inside single quotes rather than use a number, and Strings, though not an object, can use a double quotes literal
\begin{enumerate}
\item Strings are created by character arrays, using a null character (value 0), to show the end of the array, allowing it to be modified easier
\end{enumerate}
\item Variables are able to be initialized within a for loop, but are not able to be declared, such that it must be before the loop
\item ``typedef \textit{var-type} \textit{new-name}'' allows you to call an existing variable by a different name
\begin{enumerate}
\item Typedef is typically used within the header to allow the term to be used throughout the program
\end{enumerate}
\end{enumerate}

\subsection{C Compilation}
\begin{enumerate}
\item They are compiled through ``gcc \textit{file.c} -o \textit{program\_name}'', then run through ``./\textit{program\_name}''
\item C programs can be compiled into one executable, such that there is just one file after another in command line, though since they are compiled in the same namespace, they cannot have the same global variables or function names
\item The same is true for files called within other files, though those are compiled automatically
\item C programs must have exactly 1 main() function to compile, creating issues when multiple files have a main()
\item ``gcc -o \textit{file.c}'' creates a binary object .o file, which can be run through other exectuable files, and can be compounded similarly during compiling
\begin{enumerate}
\item Binary object files are used for files without a main method, and are non-executable
\item Binary object files can be linked to a .c file through compound compiling with the first file as the .c file
\item Thus, the .o file is dependant on all .h files and the .c file, while the executable is dependent on the .o files, .h files, and the main .c file
\item The .o file can then be compiled identically to .c files
\end{enumerate}
\item If ``-o \textit{program\_name}'' is not put in, the default executable name is ``a.out''
\item Projects with large numbers of dependencies can have a file called ``makefile'' to organize creation of the executable with dependencies
\begin{enumerate}
\item The makefile is ordered from the most dependent level to least dependent (ignoring non-dependent files and standard libraries)
\item Format is:
\textit{Target-Filename: dependency1 dependency2}
\textit{Terminal compilation code for file}
\item ``make \textit{target-filename}'' command is used when in the directory to compule the project using the make file
\item The clean targets can be used to remove files from the directory after compilation
\item The all target can be used to compile the entire program
\item Any bash commands can have a makefile target made, such that it can be used with a ``run'' target to run commands faster
\item The first target in a makefile is the default if just ``make'' is written in terminal
\end{enumerate}
\end{enumerate}

\subsection{C Programming}
\begin{enumerate}
\item All C programs are made up of a series of functions, run within the main function, which returns an integer (typically 0, or other values for errors)
item Libraries are added, either .h files from the current directory through \#include ``\textit{file}.h'' or through premade libraries by \#include $<$file.h$>$
\begin{enumerate}
\item All files typically start with calling the C library with \#include$<$stdio.c$>$ (standard io) and $<$stdlib.h$>$ (standard library)
\end{enumerate}
\item The man pages, called by ``man \textit{command}'' or ``man \textit{section command}'', give information on both bash and C commands
\begin{enumerate}
\item (1) is user commands, (2) is system calls, (3) is library functions, such as the C libraries, (4) is devices, (5) is file formats, (6) is games and amusements, (7) is conventions and miscellany, and (8) is system admin and priveledged commands
\item (L) is used for local commands, installed by certain programs
\end{enumerate}
\item C functions are pass by value, such that they put the value into a new variable created by the function, though if pointers are passed, it is equivelent to pass by reference, due to being a ppointer to the same location
\begin{enumerate}
\item C functions are written similar to java, with the exception of the lack of the protection
\item Due to C being functional, the functions are created in the order written, such that it should already have created all functions and commands used within the function being compiled
\item Failure to declare first leads to an implicit declaration warning that it has not been formally declared yet, though it will still work if it is declared later
\item Headers can also be placed at the top of the function in addition to where they are defined, to avoid implicit declaration, or in a seperate header file
\end{enumerate}
\end{enumerate}

\subsection{C Structures}
\begin{enumerate}
\item ``printf(\textit{text, var1, var2})'' is used to print a String in terminal, where the text is a formatted string, with placeholders for variables following
\begin{enumerate}
\item \%f is a placeholder for a float, \%d for double, \%c for char, \%s for string, \%f for pointer, \%lf for double, \%ld for long, and \%d for int
\item println can be used instead of printf for non-formatted strings (without variables)
\item Print functions do not automatically add ``\\n'' at the end of a line, and must be written in the string
\end{enumerate}
\item Arrays in C are non-dynamic, such that they must have a fixed size, with no length function, and there are no errors for going outside boundries, rather going to a different point in memory
\begin{enumerate}
\item Arrays are declared by ``\textit{type}[\textit{size}];'' and must be initialized each part at a time
\end{enumerate}
\item String functions are held within the string.h library, always assuming the strings are null-terminated
\end{enumerate}

\section{Memory Management}
\subsection{Memory Allocation}
\begin{enumerate}
\item Memory allocation is either during compile time (static stack memory), or during runtime (dynamic heap memory) - CONTRADICTION LATER????
\item Compiler allocated memory is packaged within the binary, unable to be overwritten due to protected memory, without a default value, where variables and arrays are allocated
\begin{enumerate}
\item Memory addresses of variables are fixed once they are placed, such that the data can be changed, but the location cannot be
\item String literals and variables marked by the ``const'' keyword have the value stored in stack memory as well
\end{enumerate}
\item Runtime memory is temporary, used for values of variables
\item Systems have a bit limit which they can read at once, such that 32 bit systems are limited to 32 bit unsigned values, such that $[0, 2^32-1]$ is possible, or ~4 GB 
\item Pointers are variables designed to store memory addresses
\begin{enumerate}
\item \%\textit{variable} is used to get the address of a variable, such that the number returned can be the value of a pointer 
\item When a pointer is incremented, the location moves the number of bytes of the variable type which the pointer applies to
\item * is used before a variable name to declare a pointer, and is also used when calling a variable to get the value of the item at that location, preceeding before numeric operators except ++ and --
\item Thus, for some array a, with *a as the pointer, a[i] = *(a + i)
\end{enumerate}
\end{enumerate}

\subsection{Strings and Arrays}
\begin{enumerate}
\item Strings can be declared by several methods, "char \textit{str[byte\_num]}" to do basic allocation, or it can be set on the same line, with a null put in the byte after the last letter
\begin{enumerate}
\item It can also be declared with an empty byte number, but set such that it will be given the exact amount of space needed
\item It can also be declared as a pointer to the array by "char *\textit{str = data}", created the array the exact correct size, and a pointer to the array under that variable name
\item After declaration, each character must be set individually, instead of using the equal sign
\item On the other hand, if a pointer is used, the pointer can be changed to apply to a seperate array, using an equal sign, even after declaration
\end{enumerate}
\item The null character at the end is needed for string functions in string.h to work correctly, but is not a requirement
\item String/array variables are functionally immutable pointers to the first item in an array (such that the location cannot be changed)
\item Pointer-defined strings are literals, such that they are made in protected memory, where the pointer location can be redefined, but the string cannot be
\begin{enumerate}
\item Literals of the same string will point at the same location as previously made literals, stored fully in static stack memory
\end{enumerate}
\end{enumerate}

\subsection{Dynamic Memory Allocation}
\begin{enumerate}
\item (\textit{type} *)malloc(int \textit{byte-num}) allocates that number of bytes from the head, returning the location of the first byte, typecasting the pointer to the type specified
\begin{enumerate}
\item sizeof(\textit{type}) is often used to allocate the correct amount of memory
\item calloc is a similar function that sets each bit to 0, otherwise acting like malloc, though with a first parameter to determine the number of data pieces created
\item malloc returns a void pointer, such that it can be typecast to any type of pointer
\end{enumerate}
\item realloc(void *p, int \textit{new-byte-num}) will return any extra bytes, or add additional bytes to the allocation
\item Normal memory allocation happens on the stack, automatically released after the function which created it ends
\item Dynamic memory allocation happens on the heap, kept even after the function that created it is removed from the stack, such that it must be released
\begin{enumerate}
\item free(\textit{pointer}) releases the dynamically allocated memory which the pointer goes to
\item Dynamic memory should always be released in the program when created, and can prevent filling the memory
\item After the program is ended, the memory is freed automatically, but it can freeze the computer if filled before then, such as in an infinite recursion
\end{enumerate}
\end{enumerate}

\section{Structural Functions}
\subsection{String Functions}
\begin{enumerate}
\item String functions are found within <string.h>, assuming a null character at the end
\item int strlen(char *s) returns the length of s, ignoring the null character
\item int strcmp(char *s1, char *s2) returns 0 if equal, >0 if s1 > s2, and <0 otherwise
\item char* strcpy (char *destination, char *source) copies the string to destination, assuming the allocated destination space is the same size or larger
\item char* strcat (char *destination, char *source) adds source to the end of destination
\item strncat and strncpy has an integer as a final parameter, using only the first n characters of the source string, such that if it is longer than the string, it uses up to the null character 
\end{enumerate}
\subsection{Struct}
\begin{enumerate}
\item Structs are a collection of values within a single data type, declared by struct\{\textit{type1 var1; type2 var2}\} as the type name
\begin{enumerate}
\item Typedef is used to create a simple type name for it
\item If the struct type itself is needed within the struct, it can be declared implicitly within the typedef, by putting ``struct type-name var'' instead of just the type
\end{enumerate}
\item \textit{struct-name.subvar} is used to call a specific item within the struct
\item Since . operator has precedence over *, pointers to structs either must get the struct data before getting a specific piece of data, or use ``\textit{pointer-to-struct} -> \textit{struct-var} to do 
\end{enumerate}

\end{document}
