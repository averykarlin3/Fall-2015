\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}

\begin{document}

\title{System-level Programming}
\author{Avery Karlin}
\date{Fall 2015}

\maketitle
\newpage
\tableofcontents
\vspace{11pt}
\noindent
\underline{Teacher}: Dyrland-Weaver
\newpage

\section{Learning C}
\subsection{C Primitive Variable Types}
\begin{enumerate}
\item All C primitives are numeric, divided purely based on variable size, and integer or floating point
\begin{enumerate}
\item C variables have sizes based on the platform they were compiled by and for, such that sizeof(\textit{type}) can be used to determine the size in bytes
\item On a standard computer, int = 4 $(-2^31, 2^31 - 1)$, short = 2, long = 8, float = 4, double = 8, and char = 1 bytes (8 bits to a byte)
\item Types can also be specified as unsigned, such that it is not able to be given a negative value
\item Types can be placed within types of larger size and the same format without any form of conversion, but not of a different format
\item sizeof(\textit{type}) returns the size in bytes of the type
\end{enumerate}
\item Boolean values are numbers, such that 0 is false, and all nonzero numbers are considered true
\item Character literals can be represented inside single quotes rather than use a number, and Strings, though not an object, can use a double quotes literal
\begin{enumerate}
\item Strings are created by character arrays, using a null character (value 0), to show the end of the array, allowing it to be modified easier
\end{enumerate}
\item Variables are able to be initialized within a for loop, but are not able to be declared, such that it must be before the loop
\item ``typedef \textit{var-type} \textit{new-name}'' allows you to call an existing variable by a different name
\begin{enumerate}
\item Typedef is typically used within the header to allow the term to be used throughout the program
\end{enumerate}
\end{enumerate}

\subsection{C Compilation}
\begin{enumerate}
\item They are compiled through ``gcc \textit{file.c} -o \textit{program\_name}'', then run through ``./\textit{program\_name}''
\item C programs can be compiled into one executable, such that there is just one file after another in command line, though since they are compiled in the same namespace, they cannot have the same global variables or function names
\item The same is true for files called within other files, though those are compiled automatically
\item C programs must have exactly 1 main() function to compile, creating issues when multiple files have a main()
\item ``gcc -o \textit{file.c}'' creates a binary object .o file, which can be run through other exectuable files, and can be compounded similarly during compiling
\begin{enumerate}
\item Binary object files are used for files without a main method, and are non-executable
\item Binary object files can be linked to a .c file through compound compiling with the first file as the .c file
\item Thus, the .o file is dependant on all .h files and the .c file, while the executable is dependent on the .o files, .h files, and the main .c file
\item The .o file can then be compiled identically to .c files
\end{enumerate}
\item If ``-o \textit{program\_name}'' is not put in, the default executable name is ``a.out''
\item Projects with large numbers of dependencies can have a file called ``makefile'' to organize creation of the executable with dependencies
\begin{enumerate}
\item The makefile is ordered from the most dependent level to least dependent (ignoring non-dependent files and standard libraries)
\item Format is: \\ \textit{Target-Filename: dependency1 dependency2}\\ $<$tab$>$ \textit{Terminal compilation code for file}
\item ``make \textit{target-filename}'' command is used when in the directory to compule the project using the make file
\item The clean targets can be used to remove files from the directory after compilation
\item The all target can be used to compile the entire program
\item Any bash commands can have a makefile target made, such that it can be used with a ``run'' target to run commands faster (though any target can be used)
\item The first target in a makefile is the default if just ``make'' is written in terminal
\end{enumerate}
\end{enumerate}

\subsection{C Programming}
\begin{enumerate}
\item All C programs are made up of a series of functions, run within the main function, which returns an integer (typically 0, or other values for errors)
item Libraries are added, either .h files from the current directory through \#include ``\textit{file}.h'' or through premade libraries by \#include $<$file.h$>$
\begin{enumerate}
\item All files typically start with calling the C library with \#include$<$stdio.c$>$ (standard io) and $<$stdlib.h$>$ (standard library)
\end{enumerate}
\item The man pages, called by ``man \textit{command}'' or ``man \textit{section command}'', give information on both bash and C commands
\begin{enumerate}
\item (1) is user commands, (2) is system calls, (3) is library functions, such as the C libraries, (4) is devices, (5) is file formats, (6) is games and amusements, (7) is conventions and miscellany, and (8) is system admin and priveledged commands
\item (L) is used for local commands, installed by certain programs
\end{enumerate}
\item C functions are pass by value, such that they put the value into a new variable created by the function, though if pointers are passed, it is equivelent to pass by reference, due to being a ppointer to the same location
\begin{enumerate}
\item C functions are written similar to java, with the exception of the lack of the protection
\item Due to C being functional, the functions are created in the order written, such that it should already have created all functions and commands used within the function being compiled
\item Failure to declare first leads to an implicit declaration warning that it has not been formally declared yet, though it will still work if it is declared later
\item Headers can also be placed at the top of the function in addition to where they are defined, to avoid implicit declaration, or in a seperate header file
\end{enumerate}
\end{enumerate}

\subsection{C Structures}
\begin{enumerate}
\item ``printf(\textit{text, var1, var2})'' is used to print a String in terminal, where the text is a formatted string, with placeholders for variables following
\begin{enumerate}
\item \%f is a placeholder for a float, \%d for double, \%c for char, \%s for string, \%f for pointer, \%lf for double, \%ld for long, and \%d for int
\item println can be used instead of printf for non-formatted strings (without variables)
\item Print functions do not automatically add ``\\n'' at the end of a line, and must be written in the string
\end{enumerate}
\item Arrays in C are non-dynamic, such that they must have a fixed size, with no length function, and there are no errors for going outside boundries, rather going to a different point in memory
\begin{enumerate}
\item Arrays are declared by ``\textit{type}[\textit{size}];'' and must be initialized each part at a time
\end{enumerate}
\item String functions are held within the string.h library, always assuming the strings are null-terminated
\end{enumerate}

\section{Memory Management}
\subsection{Memory Allocation}
\begin{enumerate}
\item Memory allocation is either during compile time (static stack memory), or during runtime (dynamic heap memory)
\item Compiler allocated memory is packaged within the binary, unable to be overwritten by other programs due to protected memory, without a default value, where variables and arrays are allocated
\begin{enumerate}
\item Memory addresses of variables are fixed once they are placed, such that the data can be changed, but the location cannot be
\item Variable names are not stored, but rather substituted for memory locations during compilation
\item Once the function/scope under which the stack memory created is finished, the memory is automatically released
\end{enumerate}
\item Systems have a bit limit which they can read at once, such that 32 bit systems are limited to 32 bit unsigned values, such that $[0, 2^32-1]$ is possible, or ~4 GB 
\item Pointers are variables designed to store memory addresses, stored within the stack
\begin{enumerate}
\item \%\textit{variable} is used to get the address of a variable, such that the number returned can be the value of a pointer 
\item When a pointer is incremented, the location moves the number of bytes of the variable type which the pointer applies to
\item * is used before a variable name to declare a pointer, and is also used when calling a variable to get the value of the item at that location, preceeding before numeric operators except ++ and --
\item Thus, for some array a, with *a as the pointer, a[i] = *(a + i)
\item Null pointers (set equal to the location 0) are often used to signify the end of a list
\end{enumerate}
\item Other sections in memory are code (the executable section of an object file, often stored in ROM until run), bss (global or static uninitialized variables), and data (global or static initialized variables)
\item Variables marked by the ``const'' keyword have the value stored in the read-only portion of the same memory space they would normally exist in
\item String literals are generally stored within the code section, though it can occasionally be stored in the data section as a static variable
\end{enumerate}

\subsection{Strings and Arrays}
\begin{enumerate}
\item Strings can be declared by several methods, "char \textit{str[byte\_num]}" to do basic allocation, or it can be set on the same line, with a null put in the byte after the last letter
\begin{enumerate}
\item It can also be declared with an empty byte number, but set such that it will be given the exact amount of space needed
\item It can also be declared as a pointer to the array by "char *\textit{str = data}", created the array the exact correct size, and a pointer to the array under that variable name
\item After declaration, each character must be set individually, instead of using the equal sign
\item On the other hand, if a pointer is used, the pointer can be changed to apply to a seperate array, using an equal sign, even after declaration
\end{enumerate}
\item The null character at the end is needed for string functions in string.h to work correctly, but is not a requirement
\item String/array variables are functionally immutable pointers to the first item in an array (such that the location cannot be changed)
\item Pointer-defined strings are literals, such that they are made in protected memory, where the pointer location can be redefined, but the string cannot be
\begin{enumerate}
\item Literals of the same string will point at the same location as previously made literals, stored fully in static stack memory
\end{enumerate}
\end{enumerate}

\subsection{Dynamic Memory Allocation}
\begin{enumerate}
\item (\textit{type} *)malloc(int \textit{byte-num}) allocates that number of bytes from the head, returning the location of the first byte, typecasting the pointer to the type specified
\begin{enumerate}
\item sizeof(\textit{type}) is often used to allocate the correct amount of memory
\item calloc is a similar function that sets each bit to 0, otherwise acting like malloc, though with a first parameter to determine the number of data pieces created
\item malloc returns a void pointer, such that it can be typecast to any type of pointer
\end{enumerate}
\item realloc(void *p, int \textit{new-byte-num}) will return any extra bytes, or add additional bytes to the allocation
\item Normal memory allocation happens on the stack, automatically released after the function which created it ends
\item Dynamic memory allocation happens on the heap, kept even after the function that created it is removed from the stack, such that it must be released
\begin{enumerate}
\item free(\textit{pointer}) releases the dynamically allocated memory which the pointer goes to
\item Dynamic memory should always be released in the program when created, and can prevent filling the memory
\item After the program is ended, the memory is freed automatically, but it can freeze the computer if filled before then, such as in an infinite recursion
\end{enumerate}
\end{enumerate}

\section{Structural Functions}
\subsection{String Functions}
\begin{enumerate}
\item String functions are found within <string.h>, assuming a null character at the end
\item int strlen(char *s) returns the length of s, ignoring the null character
\item int strcmp(char *s1, char *s2) returns 0 if equal, >0 if s1 > s2, and <0 otherwise
\item char* strcpy (char *destination, char *source) copies the string to destination, assuming the allocated destination space is the same size or larger
\item char* strcat (char *destination, char *source) adds source to the end of destination
\item strncat and strncpy has an integer as a final parameter, using only the first n characters of the source string, such that if it is longer than the string, it uses up to the null character 
\end{enumerate}
\subsection{Struct}
\begin{enumerate}
\item Structs are a collection of values within a single data type, declared by struct\{\textit{type1 var1; type2 var2}\} as the type name
\begin{enumerate}
\item Typedef is used to create a simple type name for it
\item If the struct type itself is needed within the struct, it can be declared implicitly within the typedef, by putting ``struct type-name var'' instead of just the type
\end{enumerate}
\item \textit{struct-name.subvar} is used to call a specific item within the struct
\item Since . operator has precedence over *, pointers to structs either must get the struct data before getting a specific piece of data, or use ``\textit{pointer-to-struct} -> \textit{struct-var} to do 
\end{enumerate}

\section{File Programming}
\subsection{Permissions}
\begin{enumerate}
\item There are 3 permission areas, each with their own permission value, first the creator (user), then a specific group of users (group), then everyone else (others), each mutually exclusive
\begin{enumerate}
\item The owner always has the ability to delete and change the permissions of a file, even if the permission value is 0
\end{enumerate}
\item ABC is the permissions of an area in binary, where A = read, B = write, C = execute, such that it can be converted into a number 0-7 in octal (which must be written in code with a 0 first, to tell the compiler it is octal)
\end{enumerate}

\subsection{Bitwise Operators}
\begin{enumerate}
\item \& is the bitwise AND operator, | is OR, ~ is NOT, and \^ is XOR
\item Bitwise operators are used to modify the actual binary of equal lengths, going bit by bit
\end{enumerate}

\subsection{File Usage}
\begin{enumerate}
\item The file table is a list of all files used by a program while it it running, containing basic information such as location and size
\begin{enumerate}
\item The file table has a limited size of $2^n$, typically 256, where getdtablesize() in ``unistd.h'' returns the size value;
\item Each file is given a descriptor, or an integer index from 0, and the table records the path, location, and other data 
\item File descriptor 0 (or STDIN\_FILENO) always refers to stdin (standard command line input), and 1 (or STDOUT\_FILENO) refers to stdout
\item File descriptor 2 (or STDERR\_FILENO) refers to stderr (standard error), which contains all error messages produced by the compiler, similar to stdout
\item These are automatically opened on the opening of a C program
\end{enumerate}
\item open(\textit{file\_path, flags, mode}) - Opens/adds the file to the first open file table space, returning the file descriptor
\begin{enumerate}
\item File descriptor -1 is returned when the file opened does not exist, or there is not permission to access the file
\item When open() fails, the variable ``errno'' in ``errno.h'' is automatically set for the specific type of error
\item strerror(\textit{int}) in ``string.h'' returns a string describing the integer stored in errno
\item Found within ``fcntl.h''
\item Flags are used to declare what the file is being used for, while mode is only used if creating the file, setting the permissions as an octal number
\item Flags can be:
\begin{itemize}
\item O\_RDONLY - Read only
\item O\_WRONLY - Write only
\item O\_RDWR - Read and Write
\item O\_APPEND - Write to end of file only
\item O\_TRUNC - Erase file and write over
\item O\_CREAT - Create file and open it if it exists
\item O\_EXCL - Can be combined with O\_CREAT to return an error if it exists
\end{itemize}
\end{enumerate}
\item close(\textit{file\_descriptor}) removes the file from the file table, found within ``unistd.h''
\item read(\textit{file\_descriptor, buffer, amount}) reads text from a file, where buffer is a pointer to where the text is placed, and amount is the bytes read
\begin{enumerate}
\item Returns the number of bytes read, or -1 if it fails (setting the errno value)
\end{enumerate}
\item unmask(\textit{mask}) sets the file creation permission mask, found within ``sys/stat.h''
\begin{enumerate}
\item Files are not initially given the permissions in the mode argument when opened, when they are created, such that a mask must be applied to modify
\item The new permissions when opened are thus ~mask \& mode, shutting off all permission from the mask
\item The mask should be in octal form, adding a new mask to the permissions
\end{enumerate}
\item lseek(\textit{file\_descriptor, offset, whence}) sets the current position in an open file, where offset is the number of bytes to move by
\begin{enumerate}
\item Whence can either be SEEK\_SET (beginning of the file), SEEK\_CUR (current position in the file), or SEEK\_END (end of the file)
\item Returns the number of bytes from the current position to the start of the file, or -1 in case of error, setting errno
\item Found within ``unistd.h''
\end{enumerate}
\item write(\textit{file\_descriptor, buffer, amount}) writes to the file the data from the buffer (which must be a pointer), where amount is the number of bytes written
\begin{enumerate}
\item Returns the int number of bytes written
\item Found within ``unistd.h''
\end{enumerate}
\end{enumerate}

\subsection{Metadata}
\begin{enumerate}
\item Metadata is information stored in the filesystem outside of files
\item ``struct stat'' is a built-in struct for metadata, where the stat(\textit{path, stat\_buffer}), where the stat buffer is the pointer to the stat struct, setting the struct to refer to the file
\item Stat struct fields include:
\begin{itemize}
\item st\_size - int, file size in bytes
\item st\_uid - int, user id
\item st\_gid - int, group id
\item st\_mode - int, file permissions
\item st\_atime - time\_t, last access time
\item st\_mtime - time\_t, last modification time
\end{itemize}
\end{enumerate}

\subsection{Directories}
\begin{enumerate}
\item Directory streams are stored within the DIR variable, and its pointer, stored along with their functions in ``dirent.h''
\item opendir(\textit{path}) - Returns a pointer to the directory stream, but does not change the current working directory (cwd)
\item closedir(\textit{directory\_stream}) - Closes the directory, and frees the stream variable automatically
\item readdir(\textit{directory\_stream}) - Returns a pointer to the next entry within the directory stream, or null if the stream is at the end
\item rewinddir(\textit{directory\_stream}) - Moves the directory stream to the start
\item ``struct dirent'' is a built-in struct for entries within a directory streams, stored within ``sys/types.h''
\begin{itemize}
\item d\_name - char[], name of files within the directory
\item d\_type - int, file type
\end{itemize}
\end{enumerate}

\subsection{Inputs}
\begin{enumerate}
\item scanf(\textit{format\_string, var1, var2, ...}) - Takes a string from stdin, matching the items from the string to variables within the format string (made up of placeholders), stored within the pointers, var1, var2, ...
\begin{enumerate}
\item sscanf(\textit{string, format\_string, var1, var2, ...}) - Takes the string, scanning data from it similarly to scanf
\end{enumerate}
\item fgets(\textit{string\_pointer, bytes, file\_pointer}) - Reads data from the file pointer to the string pointer
\begin{enumerate}
\item It stops after writing the byte number - 1 (giving space for \\0), first newline, or the end of file character, placing \\0 (null at the end)
\end{enumerate}
\end{enumerate}

\end{document}
