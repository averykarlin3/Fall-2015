\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{setspace}
\usepackage{tikz}

\begin{document}

\title{System-level Programming}
\author{Avery Karlin}
\date{Fall 2015}

\maketitle
\newpage
\tableofcontents
\vspace{11pt}
\noindent
\underline{Teacher}: Dyrland-Weaver
\newpage

\section{Learning C}
\subsection{C Primitive Variable Types}
\begin{enumerate}
\item All C primitives are numeric, divided purely based on variable size, and integer or floating point
\begin{enumerate}
\item C variables have sizes based on the platform they were compiled by and for, such that sizeof(\textit{type}) can be used to determine the size in bytes
\item On a standard computer, int = 4, short = 2, long = 8, float = 4, double = 8, and char = 1 bytes (8 bits to a byte)
\item Types can also be specified as unsigned, such that it is not able to be given a negative value
\end{enumerate}
\item Boolean values are numbers, such that 0 is false, and all nonzero numbers are considered true
\item Character literals can be represented inside single quotes rather than use a number, and Strings, though not an object, can use a double quotes literal
\begin{enumerate}
\item Strings are created by character arrays, using a null character (value 0), to show the end of the array, allowing it to be modified easier
\end{enumerate}
\item Variables are able to be initialized within a for loop, but are not able to be declared, such that it must be before the loop
\end{enumerate}

\subsection{C Programming}
\begin{enumerate}
\item All C programs are made up of a series of functions, run within the main function, which returns an integer (typically 0, or other values for errors)
\begin{enumerate}
\item They are compiled through ``gcc \textit{file.c} -o \textit{program\_name}'', then run through ``./\textit{program\_name}''
\end{enumerate}
\item Libraries are added, either .h files from the current directory through \#include ``\textit{file}.h'' or through premade libraries by \#include $<$file.h$>$
\begin{enumerate}
\item All files typically start with calling the C library with \#include$<$stdio.c$>$ and $<$stdlib.h$>$
\end{enumerate}
\item The man pages, called by ``man \textit{command}'' or ``man \textit{section command}'', give information on both bash and C commands
\begin{enumerate}
\item (1) is user commands, (2) is system calls, (3) is library functions, such as the C libraries, (4) is devices, (5) is file formats, (6) is games and amusements, (7) is conventions and miscellany, and (8) is system admin and priveledged commands
\item (L) is used for local commands, installed by certain programs
\end{enumerate}
\end{enumerate}

\subsection{C Structures}
\begin{enumerate}
\item ``printf(\textit{text, var1, var2})'' is used to print a String in terminal, where the text is a formatted string, with placeholders for variables following
\begin{enumerate}
\item \%f is a placeholder for a float, \%d for double, \%c for char, \%s for string, \%f for pointer, \%lf for double, \%ld for long, and \%d for int
\end{enumerate}
\item Arrays in C are non-dynamic, such that they must have a fixed size, with no length function, and there are no errors for going outside boundries, rather going to a different point in memory
\begin{enumerate}
\item Arrays are declared by ``\textit{type}[\textit{size}];'' and must be initialized each part at a time
\end{enumerate}
\end{enumerate}

\section{Memory Management}
\subsection{Memory Allocation}
\begin{enumerate}
\item Memory allocation is either during compile time (static stack memory), or during runtime (dynamic heap memory)
\item Compiler allocated memory is packaged within the binary, unable to overwrite other programs memory due to protected memory, without a default value, where variables and arrays are allocated
\item Runtime memory is temporary, used for values of variables
\item Pointers are variables designed to store memory addresses
\begin{enumerate}
\item \%\textit{variable} is used to get the address of a variable, such that the number returned can be the value of a pointer 
\item When a pointer is incremented, the location moves the number of bytes of the variable type which the pointer applies to
\end{enumerate}
\end{enumerate}

\subsection{Strings}
\begin{enumerate}
\item Strings can be declared by several methods, "char \textit{str[byte_num]}" to do basic allocation, or it can be set on the same line, with a null put in the byte after the last letter
\begin{enumerate}
\item It can also be declared with an empty byte number, but set such that it will be given the exact amount of space needed
\item It can also be declared as a pointer to the array by "char *\textit{str = data}", created the array the exact correct size, and a pointer to the array under that variable name
\item After declaration, each character must be set individually, instead of using the equal sign
\item On the other hand, if a pointer is used, the pointer can be changed to apply to a seperate array, using an equal sign, even after declaration
\end{enumerate}
\item The null character at the end is needed for string functions in string.h to work correctly, but is not a requirement
\item String and array variables are immutable, such that they cannot be changed without creating a different point in memory, unlike pointers
\end{enumerate}

\end{document}
